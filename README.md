[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/UMSCCg2l)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=20489852&assignment_repo_type=AssignmentRepo)
# pro1. generate PAM<sub>x</sub> matrix
* your name
* student ID

## Description

* Writing Python program to generate PAM<sub>x</sub> from the given mutation probability matrix.
* PAM<sub>x</sub> must be as a log odds and complete square matrix (rounding to integer), not the format of the given mutation probability matrix.
* Creating your own program, i.e., hw1.py, to read mut.txt and *x*, then output pamx.txt.

* You need to write your program as a function named generate_pam. i.e.,
```
def generate_pam(x, input_path, output_path):
    .
    .
    .
    .
```
* Upload your code 'hw1.py' to Gradescope under the course ID:**VWRZEN**.
* Packages you can use: numpy, pandas

### HINTs
* PAM<sub>x</sub> is a symmetric matrix even though the given mutation probability matrix is not.
* The mutation matrix should be divided by 10,000 before calculation PAM250. The value in the matrix should be in [0,1].
* Normalized frequencies of amino acids (<I>f<sub>i</sub></I>) credit by [Bioinformatics and Functional Genomics 3rd edition](https://www.wiley.com/en-us/Bioinformatics+and+Functional+Genomics,+3rd+Edition-p-9781118581780) 
![image](frequent.png)

## Parameters

* x: parameter of pam
* input_path: input file path
* output_path: output file path


## Files

* mut.txt: the input mutation probability matrix, M<sub>1</sub>
* pam250.txt: the output generated by generate_pam(250, 'example/mut.txt', 'example/pam250.txt'). The output format must be identical to the one of pam250.txt.


## Evaluation

There are 10 testing data (5 public, 5 private). 
* Correct answer gets 10 points for each testing data.


### Penalty

* If your code is similar to others and lacks detailed comments, you may lose up to 10 points or possibly receive a zero.

## References
Please provide the code along with its reference. For example, you can cite it as: ```# ChatGPT, respond to “your prompt,” on February 16, 2023```. Below is an example of a reference format summarizing the use of ChatGPT for R programming

ChatGPT 討論連結 : 
https://chatgpt.com/share/68c96923-2f54-800a-9b6c-f3a360f0aa8e

其他部分問答 : 
ChatGPT, respond to "假設已經有一個觀察到的次數矩陣 跟各胺基酸的背景頻率 求變異率與 λ在python要怎麼進行"
>在 Python 的實作範例
>下面是一個示範程式骨架，用來算 m[j] 和 λ。
```python
import numpy as np

# 假設 amino acids 是 index 0..19
# A is a 20×20 numpy array, A[i][j] = count: original j → replaced by i
# f is a length-20 numpy array, background frequencies for j (sum f = 1)

def compute_mutability_and_lambda(A, f):
    # A is 2D array shape (20,20)
    A = np.array(A, dtype=float)
    f = np.array(f, dtype=float)
    assert A.shape[0] == A.shape[1] == len(f)

    # compute n_j = total occurrences of amino acid j
    # that's the sum over i of A[i][j]
    n_j = np.sum(A, axis=0)  # sum down rows for each column j

    # compute mutability m[j] = (sum over i≠j of A[i][j]) / n_j
    # i ≠ j means subtract diagonal
    diag = np.diag(A)
    off_diag_sum = n_j - diag
    m = off_diag_sum / n_j  # array length 20

    # then compute lambda so that expected mutation rate per site = target, e.g. target = 0.01
    target_mutation_rate = 0.01
    # sum over j of f[j] * m[j]
    weighted = np.dot(f, m)  # this is Σ_j f_j * m_j
    lam = target_mutation_rate / weighted

    return m, lam

# Example usage:
# A = ... fill with your observed count matrix
# f = ... background frequencies
# m, lambda_value = compute_mutability_and_lambda(A, f)
# print(m, lambda_value)
```